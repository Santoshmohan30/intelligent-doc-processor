# Intelligent Document Processor – Backend Architecture & Engineering Overview

## 1. Project Objective

The Intelligent Document Processor is a modular backend system designed to:

- Accept document uploads (PDF, PNG, JPG)
- Perform Optical Character Recognition (OCR) using Tesseract
- Persist extracted content in a relational database
- Expose structured responses via a RESTful API

The goal of this project was not just to “run OCR,” but to build a production-style backend architecture around it. The focus was on clean structure, modular design, separation of concerns, and engineering discipline similar to real-world backend systems.

---

## 2. End-to-End System Flow

The system follows a layered backend architecture:

Client → API Layer → Service Layer → Database Layer → JSON Response

### Step 1 – Client Upload

A user uploads a document via:

POST /api/v1/documents/upload

The file is sent as multipart/form-data and received by FastAPI.

---

### Step 2 – API Layer (Routing & Validation)

The API layer is responsible for:

- Validating file input
- Restricting supported file types
- Delegating work to the service layer
- Structuring the final response

FastAPI was selected because:

- It provides automatic validation using Pydantic
- It generates OpenAPI documentation automatically
- It supports asynchronous execution (ASGI)
- It is production-ready and lightweight

The API layer contains no business logic. It strictly manages communication.

---

### Step 3 – Service Layer (Business Logic)

The service layer handles:

- Saving uploaded files
- Calling the OCR engine
- Measuring processing time
- Handling exceptions
- Returning structured processing results

This separation ensures:

- Clean architecture
- Easier testing
- Replaceability (OCR engine can be swapped later)
- Better maintainability

---

### Step 4 – OCR Engine (Tesseract)

Tesseract performs Optical Character Recognition by:

- Analyzing image pixel structures
- Detecting character patterns
- Converting images into readable text

It transforms unstructured image data into machine-readable text.

Tesseract was chosen because:

- It is open-source and stable
- It integrates easily with Python
- It does not require external API calls
- It allows full local control of processing

---

### Step 5 – Database Layer (Persistence)

The project uses:

- SQLite (for development)
- SQLAlchemy ORM (for abstraction)

The Document model stores:

- ID (primary key)
- Filename
- File size
- File type
- Extracted text
- Processing time
- Status
- Created and updated timestamps

Using SQLAlchemy provides:

- Database abstraction
- Clean schema modeling
- Easier migration to PostgreSQL or other databases
- Reduced raw SQL complexity

---

### Step 6 – JSON Response

After processing, the API returns structured JSON:

```json
{
  "message": "Document processed successfully",
  "document": {
    "id": 1,
    "filename": "receipt.png",
    "extracted_text": "...",
    "processing_time": 0.53,
    "status": "completed"
  }
}
